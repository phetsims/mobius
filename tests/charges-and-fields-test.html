<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <title>Charges and Fields Proof of Concept</title>

  <style type="text/css">
    canvas {
      position: absolute;
      left: 0;
      top: 0;
    }
  </style>
</head>
<body>
<canvas id="canvas" width="512" height="512"></canvas>

<script type="text/javascript">
  // polyfill requestAnimationFrame
  ( function() {
    var lastTime = 0;
    var vendors = [ 'ms', 'moz', 'webkit', 'o' ];
    for ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
      window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
      window.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];
    }

    if ( !window.requestAnimationFrame ) {
      window.requestAnimationFrame = function( callback ) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
        var id = window.setTimeout( function() {
          callback( currTime + timeToCall );
        }, timeToCall );
        lastTime = currTime + timeToCall;
        return id;
      };
    }

    if ( !window.cancelAnimationFrame ) {
      window.cancelAnimationFrame = function( id ) {
        clearTimeout( id );
      };
    }
  } )();

  window.addEventListener( 'load', function() {
    var canvas = document.getElementById( 'canvas' );

    var resizer = function() {
      var size = Math.min( window.innerWidth, window.innerHeight );
      canvas.width = size;
      canvas.height = size;
    };
    window.addEventListener( 'resize', resizer );
    resizer();

    var gl = canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' );

    function createShader( source, type ) {
      var shader = gl.createShader( type );
      gl.shaderSource( shader, source );
      gl.compileShader( shader );

      if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
        console.log( gl.getShaderInfoLog( shader ) );
        console.log( source );
        throw new Error( 'GLSL compile error: ' + gl.getShaderInfoLog( shader ) );
      }

      return shader;
    }

    var program = gl.createProgram();

    /*
                    var ratio: Number = model.getVRatio( ox + halfstep, oy + halfstep );

              if ( ratio > 0 ) {
                  var c: Number = Math.floor( ((1 - ratio) * 255) );
                  if ( c < 0 ) {
                      c = 0;
                  }
                  red = 255;
                  green = blue = c;
              }
              else {
                  c = Math.floor( ((1 + ratio) * 255) );
                  if ( c < 0 ) {
                      c = 0;
                  }
                  blue = 255;
                  green = red = c;
              }
    */

    var vertexShader = createShader(
      'attribute vec3 vertex;\n' +
      'varying vec2 texCoord;\n' +
      'void main() {\n' +
      '  texCoord = vertex.xy * 0.5 + 0.5;\n' +
      '  gl_Position = vec4( vertex, 1 );\n' +
      '}', gl.VERTEX_SHADER );
    var fragmentShader = createShader(
      'precision highp float;\n' +
      'varying vec2 texCoord;\n' +
      'uniform vec2 p1;\n' +
      'uniform vec2 p2;\n' +
      'uniform vec2 p3;\n' +
      'uniform vec2 p4;\n' +
      'void main() {\n' +
      '  float ratio = 0.0' +
      ' + 1.0 / distance( texCoord, p1 )' +
      ' - 1.0 / distance( texCoord, p2 )' +
      ' + 1.0 / distance( texCoord, p3 )' +
      ' - 1.0 / distance( texCoord, p4 )' +
      ';\n' +
      '  float m = 1.0 - abs( ratio * 0.05 );\n' +
      '  gl_FragColor = vec4( ratio > 0.0 ? vec3( 1.0, m, m ) : vec3( m, m, 1.0 ), 1.0 );\n' +
      '}', gl.FRAGMENT_SHADER );

    gl.attachShader( program, vertexShader );
    gl.attachShader( program, fragmentShader );

    gl.linkProgram( program );

    if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {
      console.log( gl.getProgramInfoLog( program ) );
      throw new Error( 'GLSL link error: ' + gl.getProgramInfoLog( program ) );
    }

    gl.deleteShader( vertexShader );
    gl.deleteShader( fragmentShader );

    var aVertexLocation = gl.getAttribLocation( program, 'vertex' );
    var p1Location = gl.getUniformLocation( program, 'p1' )
    var p2Location = gl.getUniformLocation( program, 'p2' )
    var p3Location = gl.getUniformLocation( program, 'p3' )
    var p4Location = gl.getUniformLocation( program, 'p4' )

    gl.useProgram( program );
    gl.enableVertexAttribArray( aVertexLocation );

    var vertexBuffer = gl.createBuffer();
    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [
      -1, -1,
      -1, +1,
      +1, -1,
      +1, +1
    ] ), gl.STATIC_DRAW );

    var moveX = 0;
    var moveY = 1.0;

    window.addEventListener( 'mousemove', function( evt ) {
      moveX = evt.clientX / canvas.width;
      moveY = 1 - evt.clientY / canvas.height;
    } );

    function render() {
      gl.uniform2f( p1Location, 0.8, 0.3 );
      gl.uniform2f( p2Location, 0.3, 0.2 );
      gl.uniform2f( p3Location, 0.5, 0.8 );
      gl.uniform2f( p4Location, moveX, moveY );

      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
      gl.vertexAttribPointer( aVertexLocation, 2, gl.FLOAT, false, 0, 0 );
      gl.drawArrays( gl.TRIANGLE_STRIP, 0, 4 );
    }

    ( function step() {
      window.requestAnimationFrame( step );

      render();
    } )();
  } );
</script>
</body>
</html>
